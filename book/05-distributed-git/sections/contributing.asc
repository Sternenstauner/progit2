[[_contributing_project]]
=== An einem Projekt mitarbeiten

(((contributing)))
<<<<<<< HEAD
Die größte Schwierigkeit bei der Beschreibung der Mitarbeit an einem Projekt besteht darin, dass es eine große Anzahl von Variationen gibt, wie dies geschehen kann.
Da Git sehr flexibel ist, bietet es den Menschen viele Möglichkeiten der Zusammenarbeit, und es ist problematisch zu beschreiben, wie Sie mitarbeiten sollten, da jedes Projekt ein bisschen anders ist.
Einige der variablen Größen dabei sind die Anzahl der aktiven Mitarbeiter, der gewählte Arbeitsablauf, Ihre Zugriffsrechte und möglicherweise eine externe Methode der Mitarbeit.

Die erste variable Größe ist die Anzahl der aktiven Mitarbeiter - wie viele Nutzer steuern aktiv Code zu diesem Projekt bei und wie häufig?
In vielen Fällen gibt es zwei oder drei Entwickler mit ein paar Commits pro Tag, oder auch weniger bei irgendwie ruhenden Projekten.
Bei größeren Firmen oder Projekten kann die Anzahl der Entwickler in die Tausende reichen mit hunderten oder tausenden eingehenden Commits pro Tag.
Das ist deshalb von Bedeutung, da Sie mit einer wachsenden Anzahl von Entwicklern auch sicherstellen müssen, dass sich der Code problemlos anwenden lässt und leicht zusammengeführt werden kann.
Änderungen, die Sie übermitteln, können sich als überflüssig oder dysfunktional erweisen durch Beiträge, die inzwischen eingefügt wurden, während Sie noch an ihren Änderungen arbeiteten oder darauf warteten, dass diese geprüft oder angewendet werden.
Wie können Sie Ihren Code permanent auf dem neusten Stand halten und dafür sorgen, dass Ihre Commits gültig sind?

Die nächste Variable ist der für das Projekt verwendete Arbeitsablauf.
Ist es ein zentralisierter Arbeitsablauf, in dem jeder Entwickler die gleichen Schreibrechte auf die Hauptentwicklungslinie hat?
Gibt es bei dem Projekt einen Projektbetreiber oder Integrationsmanager, der alle Patches prüft?
Werden die Patches durch eine bestimmte Gruppe oder öffentlich, z. B. durch die Community, geprüft?
Sind Sie selbst an diesem Prozess beteiligt?
Gibt es ein Leutnant-System und müssen Sie Ihre Arbeit zunächst an einen solchen übermitteln?

Eine weiteres Thema sind ihre Commit-Zugriffsrechte.
Der erforderliche Arbeitsablauf, um Änderungen zu einem Projekt beizusteuern, ist ein ganz anderer, wenn Sie über Schreibrechte verfügen, als wenn das nicht der Fall ist.
Und wenn Sie keine Schreibrechte haben, in welcher Form müssen Sie ihre Änderungen bei diesem Projekt vorzugsweise übermitteln?
Gibt es dafür überhaupt eine Richtlinie?
Wie umfangreich sind die Änderungen, die Sie jeweils beisteuern?
Und wie häufig tun Sie das?

All diese Aspekte haben Einfluss darauf, wie Sie effektiv an einem Projekt mitarbeiten können und welche Arbeitsabläufe bevorzugt werden oder verfügbar für Sie sind.
Wir werden verschiedene Aspekte davon in einer Reihe von Fallbeispielen betrachten, wobei wir mit simplen Beispielen anfangen und später komplexere Szenarios besprechen. Sie sollten in der Lage sein, anhand dieser Beispiele die spezifischen Arbeitsabläufe zu erstellen, die Sie in der Praxis benötigen.
=======
The main difficulty with describing how to contribute to a project is that there are a huge number of variations on how it's done.
Because Git is very flexible, people can and do work together in many ways, and it's problematic to describe how you should contribute – every project is a bit different.
Some of the variables involved are active contributor count, chosen workflow, your commit access, and possibly the external contribution method.

The first variable is active contributor count – how many users are actively contributing code to this project, and how often?
In many instances, you'll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.
For larger companies or projects, the number of developers could be in the thousands, with hundreds or thousands of commits coming in each day.
This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged.
Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied.
How can you keep your code consistently up to date and your commits valid?

The next variable is the workflow in use for the project.
Is it centralized, with each developer having equal write access to the main codeline?
Does the project have a maintainer or integration manager who checks all the patches?
Are all the patches peer-reviewed and approved?
Are you involved in that process?
Is a lieutenant system in place, and do you have to submit your work to them first?

The next variable is your commit access.
The workflow required in order to contribute to a project is much different if you have write access to the project than if you don't.
If you don't have write access, how does the project prefer to accept contributed work?
Does it even have a policy?
How much work are you contributing at a time?
How often do you contribute?

All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you.
We'll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[[_commit_guidelines]]
==== Richtlinien für Commits

Bevor wir damit beginnen, spezifische Anwendungsfälle zu betrachten, hier noch eine kurze Anmerkung zu Commit-Nachrichten.
Ein gute Richtlinie für das Erzeugen von Commits zu haben und sich daran zu halten, macht die Arbeit mit Git und die Zusammenarbeit mit anderen um vieles leichter.
Das Git-Projekt stellt ein Dokument bereit, welches eine Reihe von guten Tipps für das Erzeugen von Commits zum Übermitteln von Patches beinhaltet. Sie können die Tipps in der Datei `Documentation/SubmittingPatches` im Git-Quellcode nachlesen.

(((git commands, diff, check)))
<<<<<<< HEAD
Als Erstes wollen Sie keinerlei Leerzeichenfehler übermitteln.
Git bietet eine einfache Möglichkeit, dies zu überprüfen - bevor Sie einen Commit vornehmen, führen Sie die Anweisung `git diff --check` aus, welche mögliche Leerzeichenfehler erkennt und für Sie auflistet. 

.Ausgabe von `git diff --check`.
image::images/git-diff-check.png[Ausgabe von `git diff --check`.]

Wenn Sie diese Anweisung vor einem Commit ausführen, können Sie erkennen, ob Sie dabei sind, Leerzeichenfehler zu übermitteln, welche andere Entwickler verärgern könnten.

Als Nächstes, versuchen Sie, aus jedem Commit einen logisch getrennten Satz von Änderungen zu machen.
Wenn Sie können, versuchen Sie, Ihre Änderungen leicht verdaulich zu machen - arbeiten Sie nicht ein ganzes Wochenende an fünf verschiedenen Themen und übermitteln Sie dann all diese Änderungen in einem massiven Commit am Montag.
Auch wenn Sie am Wochenende keine Commits durchführen, nutzen Sie am Montag die Staging Area, um Ihre Änderungen aufzuteilen in wenigstens einen Commit für jeden Teilaspekt mit jeweils einer sinnvollen Nachricht.
Wenn einige der Änderungen die selbe Datei modifizieren, benutzen Sie die Anweisung `git add --patch`, um Dateien partiell zur Staging Area hinzuzufügen (detailiert dargestellt im Abschnitt <<_interactive_staging>>).
Der Schnappschuss vom Projekt an der Spitze des Branches ist der Selbe, ob Sie einen oder fünf Commits durchgeführt haben, solange nur all die Änderungen irgendwann hinzugefügt werden. Versuchen Sie also, die Dinge zu vereinfachen für Ihre Entwicklerkollegen, die Ihre Änderungen begutachten müssen.
Dieser Ansatz macht es außerdem einfacher, einen Satz von Änderungen zu entfernen oder rückgängig zu machen, falls das später nötig wäre.
<<_rewriting_history>> beschreibt eine Reihe nützlicher Git-Tricks zum Umschreiben des Verlaufs oder um interaktiv Dateien zur Staging Area hinzuzufügen. Verwenden Sie diese Werkzeuge, um einen sauberen und leicht verständlichen Verlauf aufzubauen, bevor Sie Ihre Arbeit jemand anderem schicken.

Ein weitere Sache, die Sie nicht vergessen sollten, ist die Commit-Nachricht.
Wenn man sich angewöhnt, aussagekräftige und hochwertige Commit-Nachrichten zu schreiben, ist die Benutzung von Git viel einfacher und es erleichtert die Zusammenarbeit.
In der Regel sollte Ihre Commit-Nachricht mit einer einzelnen Zeile anfangen, die nicht länger als 50 Zeichen sein sollte und die Änderungen kurz und bündig beschreibt, gefolgt von einer leeren Zeile, welcher eine ausführlichere Beschreibung der Änderungen folgt.
Das Git-Projekt fordert, dass die detailliertere Erklärung Ihre Motivation für die Änderungen beinhaltet und deren Implementierung dem vorhergehenden Verhalten gegenüberstellt. Das ist eine gute Richtlinie, an die man sich halten sollte.
Es empfiehlt sich außerdem, die Gegenwartsform des Imperativ in diesen Nachrichten zu benutzen.
Mit anderen Worten, nutzen Sie Anweisungen.
Anstatt ``Ich habe Test hinzugefügt für'' oder ``Tests hinzufügend für'' benutzen Sie ``Füge Tests hinzu für''.
Hier ist ein Muster, welches ursprünglich von Tim Pope stammt:

[source,text]
-----
Kurze (50 Zeichen oder weniger) Zusammenfassung der Änderungen
=======
First, you don't want to submit any whitespace errors.
Git provides an easy way to check for this – before you commit, run `git diff --check`, which identifies possible whitespace errors and lists them for you.

.Output of `git diff --check`.
image::images/git-diff-check.png[Output of `git diff --check`.]

If you run that command before committing, you can tell if you're about to commit whitespace issues that may annoy other developers.

Next, try to make each commit a logically separate changeset.
If you can, try to make your changes digestible – don't code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.
Even if you don't commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.
If some of the changes modify the same file, try to use `git add --patch` to partially stage files (covered in detail in <<_interactive_staging>>).
The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes.
This approach also makes it easier to pull out or revert one of the changesets if you need to later.
<<_rewriting_history>> describes a number of useful Git tricks for rewriting history and interactively staging files – use these tools to help craft a clean and understandable history before sending the work to someone else.

The last thing to keep in mind is the commit message.
Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier.
As a general rule, your messages should start with a single line that's no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.
The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior – this is a good guideline to follow.
It's also a good idea to use the imperative present tense in these messages.
In other words, use commands.
Instead of ``I added tests for'' or ``Adding tests for,'' use ``Add tests for.''
Here is a http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html[template originally written by Tim Pope]:

[source,text]
----
Short (50 chars or less) summary of changes
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

Detailliert erklärender Text, wenn nötig. Beschränken Sie
diesen auf ca. 72 Zeichen. In Abhängigkeit vom Kontext wird
die erste Zeile manchmal wie die Betreff-Zeile einer E-Mail
behandelt und der übrige Text wie der Textkörper der
Nachricht. Die leere Zeile, welche die Zusammenfassung vom
Text trennt, ist kritisch (außer Sie lassen den Text komplett
weg); Werkzeuge wie Rebase können durcheinander kommen, wenn
Sie beide gleichzeitig verwenden.

Weitere Absätze folgen jeweils nach leeren Zeilen.

  - Aufzählungspunkte kann man auch verwenden

<<<<<<< HEAD
  - Typischer Weise nutzt man Bindestriche oder Sternchen
    als Aufzählungszeichen, denen ein einzelnes Leerzeichen
	vorangestellt wird, die einzelnen Punkte werden durch
    leere Zeilen getrennt, die Konventionen variieren hier
	
-----
=======
  - Typically a hyphen or asterisk is used for the bullet,
    preceded by a single space, with blank lines in
    between, but conventions vary here
----
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

Wenn alle Ihre Commit-Nachrichten so aussehen, werden die Dinge für Sie und die Entwickler, mit denen Sie zusammenarbeiten, viel einfacher sein.
Das Git-Projekt selbst hat wohl-formatierte Commit-Nachrichten - führen Sie mal die Anweisung `git log --no-merges` aus, um zu sehen, wie ein angenehm formatierter Commit-Verlauf eines Projektes aussieht.

In den folgenden Beispielen und fast überall in diesem Buch finden Sie der Kürze halber keine angenehm formatierten Meldungen wie diese. Stattdessen wird die Anweisung `git commit` zusammen mit der Option `-m` verwendet.
Also folgen Sie meinen Worten und nicht meinem Beispiel.

<<<<<<< HEAD
=======
For the sake of brevity, the following examples, and most examples in other parts of this book,  don't have nicely-formatted messages like this; instead, we use the `-m` option to `git commit`.
Do as we say, not as we do.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[[_private_team]]
==== Vertrauliches kleines Team

(((contributing, private small team)))
Das einfachste Szenario, dem Sie sehr wahrscheinlich begegnen werden, ist ein vertrauliches Projekt mit einem oder zwei Entwicklern.
``Private'' in diesem Zusammenhang bedeutet "closed source" - nicht öffentlich zugänglich für die Außenwelt.
Sie und die anderen Entwickler haben alle Schreibzugriff auf das Repository.

Sie können sich in diesem Umfeld an einen Arbeitsablauf halten, den Sie genauso auch bei Subversion oder einem anderen zentralisierten System verwenden könnten.
Sie genießen dann immer noch die Vorteile von Dingen, wie Commits offline durchführen zu können und erheblich einfacher Branches anzulegen und zusammenzuführen, aber der Arbeitsablauf kann sehr ähnlich sein. Der Hauptunterschied ist, dass das Zusammenführen eher auf der Client-Seite stattfindet als auf dem Server beim Durchführen eines Commits.
Lassen Sie uns betrachten, wie es aussehen könnte, wenn zwei Entwickler damit beginnen, an einem gemeinsamen Repository zu arbeiten.
Der erste Entwickler, John, klont das Repository, nimmt eine Änderung vor und führt lokal einen Commit durch.
(Die Protokoll-Nachrichten wurden in diesen Beispielen durch `...` ersetzt, um das Ganze etwas zu kürzen.)

[source,console]
----
# John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'remove invalid default value'
[master 738ee87] remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Die zweite Entwicklerin, Jessica, tut das Selbe. Sie klont das Repository, ändert etwas und führt einen Commit durch.

[source,console]
----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Nun lädt Jessica ihre Arbeit auf den Server hoch:

[source,console]
----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
----

John versucht ebenfalls, seine Änderungen hochzuladen:

[source,console]
----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
----

John ist es nicht gestattet, seine Änderungen hochzuladen, weil Jessica inzwischen ihre hochgeladen hat.
Dies zu verstehen, ist besonders wichtig, wenn Sie dem Umgang mit Subversion gewöhnt sind, weil Sie bemerkt haben werden, dass die beiden Entwickler nicht die gleiche Datei bearbeitet haben.
Obwohl Subversion automatisch das Zusammenführen auf dem Server durchführt, wenn zwei verschiedene Dateien bearbeitet werden, müssen Sie die Commits bei Git lokal zusammenführen.
John muss erst Jessicas Änderungen abholen und lokal mit seinen zusammenführen, bevor ihm das Hochladen gestattet wird.

[source,console]
----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
----

Zu diesem Zeitpunkt sieht Johns lokales Repository ungefähr so aus:

.Johns abzweigender Verlauf.
image::images/small-team-1.png[John's divergent history.]

John hat einen Bezug zu den Änderungen, welche Jessica hochgeladen hat, aber er muss diese erst mit seiner eigenen Arbeit zusammenführen, bevor es ihm gestattet ist, selbst hochzuladen.

[source,console]
----
$ git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
----

Das Zusammenführen läuft problemlos - Johns Commit-Verlauf sieht jetzt so aus:

.Johns Repository nach dem Zusammenführen mit `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]

Jetzt kann John seinen Code überprüfen, um sicherzustellen, dass dieser immer noch ordnungsgemäß funktioniert, und dann kann er seine neue, zusammengeführte Arbeit auf den Server hochladen:

[source,console]
----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
----

Schließlich sieht Johns Commit-Verlauf so aus:

.Johns Verlauf nach dem Hochladen auf den `origin`-Server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]

Jesicca hat in der Zwischenzeit an einem Themenbranch gearbeitet.
Sie hat einen Themenbranch namens `issue54` erzeugt und auf diesem Branch drei Commits durchgeführt.
Noch hat sie Johns Änderungen nicht vom Server abgeholt, sodass ihr Commit-Verlauf jetzt so aussieht:

.Jessicas Themenbranch.
image::images/small-team-4.png[Jessica's topic branch.]

Jessica möchte ihren Stand mit Johns synchronisieren, also führt sie die Anweisung `git fetch origin` aus:

[source,console]
----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
----

Das lädt alle Änderungen herunter, die John in der Zwischenzeit hochgeladen hat.
Jessicas Verlauf sieht nun so aus:

.Jessicas Verlauf nach dem Abholen von Johns Änderungen.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]

Jessica denkt, dass ihr Themenbranch fertig ist, aber sie möchte wissen, welche Änderung sie mit ihrer Arbeit zusammenführen muss, damit sie ihrerseits hochladen kann.
Sie führt die Anweisung `git log` aus, um dies herauszufinden:

[source,console]
----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   remove invalid default value
----

<<<<<<< HEAD
Bei der Syntax `issue54..origin/master` handelt es sich um einen log-Filter, der Git anweist, nur die Commits aufzulisten, welche auf dem letzteren Branch durchgeführt wurden (in diesem Fall `origin/master`) und die sich nicht auf dem ersten Branch befinden (in diesem Fall `issue54`). Wir werden uns diese Syntax detailliert in <<_commit_ranges>>.

Fürs Erste können wir an der Ausgabe erkennen, dass es einen einzelnen Commit von John gibt, den Jessica noch nicht bei sich eingefügt hat. Dieser einzelne Commit modifiziert ihre lokalen Änderungen, wenn sie ihren Branch mit `origin/master` zusammenführt. 
=======
The `issue54..origin/master` syntax is a log filter that asks Git to only show the list of commits that are on the latter branch (in this case `origin/master`) that are not on the first branch (in this case `issue54`).
We'll go over this syntax in detail in <<_commit_ranges>>.

For now, we can see from the output that there is a single commit that John has made that Jessica has not merged in.
If she merges `origin/master`, that is the single commit that will modify her local work.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

Jetzt kann Jessica ihren Themenbranch mit ihrem `master`-Branch zusammenführen, danach Johns Arbeit (`origin/master`) mit ihrem `master`-Branch zusammenführen und dann das Ganze auf den Server hochladen.
Zuerst wechselt sie zu ihrem `master`-Branch, um alle diese Änderungen zu integrieren:

[source,console]
----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
----

Sie kann entweder `origin/master` oder `issue54` zuerst integrieren, da sie beide "stromaufwärts" angeordnet sind, spielt die Reihefolge keine Rolle.
Der Snapshot am Ende sollte identisch sein, egal, welche Reihenfolge sie wählt, nur der Verlauf wird ein wenig anders sein.
Sie entscheidet sich dafür, `issue54` zuerst einfließen zu lassen.

[source,console]
----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
----

Es treten keine Probleme auf; wie Sie sehen können, war es ein einfacher "Fast-Forward".
Nun integriert Jessica die Arbeit von John (`origin/master`):

[source,console]
----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
----

Alles lässt sich sauber zusammenführen und Jessicas Verlauf sieht jetzt so aus:

.Jessicas Verlauf nach dem Zusammenführen mit Johns Änderungen.
image::images/small-team-6.png[Jessica's history after merging John's changes.]

Jetzt ist `origin/master` von Jessicas `master`-Branch aus erreichbar, sodass sie in der Lage sein sollte, erfolgreich hochladen zu können (vorausgesetzt, John hat nicht inzwischen schon wieder etwas hochgeladen):

[source,console]
----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
----

Jeder Entwickler hat einige Commits durchgeführt und jeweils die Arbeiten des anderen mit den eigenen zusammengeführt.

.Jessicas Verlauf nach dem Hochladen aller Änderungen auf den Server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]

<<<<<<< HEAD
Das ist einer der einfachsten Arbeitsabläufe.
Sie arbeiten eine Weile, gewöhnlich an einem Themenbranch, und führen diesen mit ihrem master-Branch zusammen, wenn dieser soweit fertig ist, dass er integriert werden kann.
Wenn Sie diese Arbeit mit anderen teilen wollen, führen Sie die Änderungen mit ihrem eigenen `master`-Branch zusammen, holen eventuelle Änderungen vom Branch `origin/master` ab und führen diese mit ihren `master`-Branch zusammen, und schließlich laden sie alles auf den `master`-Branch auf den Server hoch.
Der generelle Ablauf sieht ungefähr so aus:
=======
That is one of the simplest workflows.
You work for a while, generally in a topic branch, and merge into your `master` branch when it's ready to be integrated.
When you want to share that work, you fetch and merge your `master` from `origin/master` if it has changed, and finally push to the `master` branch on the server.
The general sequence is something like this:
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

.Genereller Ablauf von Ereignissen für einen einfachen Arbeitsablauf mit mehreren Entwicklern.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]

==== Geführte vertrauliche Teams

(((contributing, private managed team)))
In diesem Szenario werden Sie die Funktionen von Mitarbeitern in einem größeren, nicht öffentlich arbeitenden Team betrachten.
Sie werden erfahren, wie Sie in einem Umfeld arbeiten können, wo in kleinen Gruppen an der Entwicklung einzelner Features gearbeitet wird und dann diese team-basierten Beiträge durch einen anderen Beteiligten integriert werden.

Sagen wir, John und Jessica arbeiten gerade zusammen an einem Feature, während Jessica und Josie gerade an einem zweiten arbeiten.
Das Unternehmen benutzt in diesem Fall einen Typ des Arbeitsablaufs mit Integrationsmanager, bei dem die Arbeit der individuellen Gruppen nur durch bestimmte Mitarbeiter integriert wird und der `master`-Branch des Haupt-Repositorys auch nur durch eben diese Mitarbeiter aktualisiert werden kann.
Die ganze Arbeit wird in diesem Szenario auf team-basierten Branches ausgeführt und später von den Integrationsmanagern zusammengeführt.

Lassen Sie uns Jessicas Arbeitsablauf betrachten, wie sie in diesem Umfeld parallel mit zwei verschiedenen Entwicklern an ihren beiden Features arbeitet.
Vorausgesetzt, sie hat ihr Repository bereits geklont, entscheidet sie sich, zuerst an `featureA` zu arbeiten.
Sie erzeugt einen neuen Branch für das Feature und arbeitet etwas daran:

[source,console]
----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
----

An diesem Punkt muss sie den Stand ihrer Arbeiten John mitteilen, also lädt sie ihre Commits von `featureA`-Branch auf den Server hoch.
Jessica hat keine Schreibrechte auf dem `master`-Branch - den haben nur die Integrationsmanager - also muss sie auf einen anderen Branch hochladen, um mit John zusammenarbeiten zu können.

[source,console]
----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
----

<<<<<<< HEAD
Jessica sendet John eine E-Mail, um ihm mitzuteilen, dass einige Änderungen auf einen neuen Branch namens `featureA` hochgeladen hat und er nun einen Blick darauf werfen kann.
Während sie auf ein Feedback von John wartet, entscheidet sich Jessica, mit der Arbeit an `featureB` zu beginnen - diesmal gemeinsam mit Josie.
Am Anfang legt sie einen neuen Feature-Branch an, basierend auf dem `master`-Branch, welcher sich auf dem Server befindet (`origin/master`):  
=======
Jessica emails John to tell him that she's pushed some work into a branch named `featureA` and he can look at it now.
While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.
To begin, she starts a new feature branch, basing it off the server's `master` branch:
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[source,console]
----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
----

Jetzt führt Jessica eine Reihe von Commits auf dem `featureB`-Branch durch:

[source,console]
----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
----

Jessicas Repository sieht jetzt so aus:

.Jessicas ursprünglicher Commit-Verlauf.
image::images/managed-team-1.png[Jessica's initial commit history.]

<<<<<<< HEAD
Jessica könnte ihre Arbeit jetzt hochladen, aber sie bekommt eine E-Mail von Josie, in der diese mitteilt, dass bereits ein Branch namens `featureBee` hochgeladen wurde, welcher einige erste Änderungen beinhaltet.
Jessica muss also erst diese Änderungen mit ihren eigenen Änderungen zusammenführen, bevor sie selbst etwas hochladen kann.
Sie kann Josies Änderungen mit `git fetch` herunterladen:
=======
She's ready to push up her work, but gets an email from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.
Jessica first needs to merge those changes in with her own before she can push to the server.
She can then fetch Josie's changes down with `git fetch`:
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
----

Jessica kann jetzt dies mit den Änderungen, die sie vorgenommen hat, zusammenführen:

[source,console]
----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
----

Dabei gibt es ein kleines Problem - sie muss die zusammengeführten Änderungen in ihrem `featureB`-Branch in den `featureBee`-Branch auf dem Server hochladen.
Sie kann dies erledigen, indem sie die Anweisung `git push` verwendet und dabei den lokalen Branch festlegt, gefolgt von einem Doppelpunkt (:), gefolgt vom Branch auf dem entfernten Server:

[source,console]
----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
----

Das bezeichnet man als _refspec_.
Siehe <<_refspec>> für detailliertere Diskussionen von Gits refspecs und verschiedenden Dingen, die Sie damit machen können.
Beachten Sie auch die Option `-u`; das ist die Kurzform von `--set-upstream`, welche die Branches für ein einfacheres Hoch- und Herunterladen konfiguriert.

<<<<<<< HEAD
Als Nächstes sendet John eine E-Mail an Jessica, um sie zu informieren, dass er einige Änderungen auf den `featureA`-Branch hochgeladen hat, und um sie zu bitten, diese zu überprüfen.
Sie führt die Anweisung `git fetch` aus, um diese Änderungen herunter zu laden:
=======
Next, John emails Jessica to say he's pushed some changes to the `featureA` branch and asks her to verify them.
She runs a `git fetch` to pull down those changes:
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[source,console]
----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
----

Um zu sehen, was geändert wurde, benutzt sie die Anweisung `git log`:

[source,console]
----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
----

Schließlich lässt sie Johns Änderungen in ihren eigenen `featureA`-Branch einfließen: 

[source,console]
----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
----

Jessica möchte etwas optimieren, also führt sie wieder einen Commit durch und lädt dann das Ganze auf den Server hoch:

[source,console]
----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
----

Jessicas Commit-Verlauf sieht jetzt ungefähr so aus:

.Jessicas Verlauf nach dem Commit auf den Feature-Branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]

Jessica, Josie und John informieren die Integrationsmanager, dass die Branches `featureA` und `featureBee` auf dem Server soweit fertiggestellt sind, um in die Hauptlinie integriert zu werden.
Nachdem die Integrationsmanager diese Branches mit der Hauptlinie zusammengeführt haben, wird beim Abholen der Daten vom Server der neue Merge-Commit heruntergeladen, was den Commit-Verlauf dann so aussehen lässt:

.Jessicas Verlauf nach dem Zusammenführen mit ihren beiden Themenbranches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]

Viele Teams wechseln zu Git, weil es damit möglich ist, dass mehrere Teams parallel arbeiten können und die verschiedenen Entwicklungslinien erst später im Prozess zusammengeführt werden.
Ein riesiger Vorteil von Git besteht darin, dass man in kleinen Untergruppen eines Teams über entfernte Branches zusammenarbeiten kann, ohne notwendigerweise das gesamte Team zu involvieren oder zu behindern.
Die Reihenfolge bei dem Arbeitsablauf, den Sie gesehen haben, ist ungefähr folgende:

.Grundlegende Reihenfolge des Arbeitsablaufs bei einem geführten Team.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]

[[_public_project]]
==== Verteiltes öffentliches Projekt

(((contributing, public small project)))
<<<<<<< HEAD
An einem öffentlichen Projekt mitzuarbeiten, ist ein wenig anders.
Da Sie keine Berechtigungen haben, die Branches des Projektes direkt zu aktualisieren, müssen Sie die Änderungen auf andere Art und Weise zu den Projektbetreibern bekommen.
Dieses erste Beispiel beschreibt die Mitarbeit mittels "Forking" auf Git-Hosting-Servern, welche einfaches "Forking" unterstützen.
Viele Hosting-Websites unterstützen dies (einschließlich GitHub, BitBucket, Google Code repo.or.cz und andere), und viele Projektbetreiber erwarten diese Art der Zuarbeit.
Der nächste Abschnitt handelt von Projekten, welche die Abgabe von Patches bevorzugt via E-Mail akzeptieren.
=======
Contributing to public projects is a bit different.
Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
This first example describes contributing via forking on Git hosts that support easy forking.
Many hosting sites support this (including GitHub, BitBucket, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via email.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

Zunächst werden Sie vermutlich das Hauptrepository klonen wollen, einen Themenbranch anlegen für den Patch oder die Serie von Patches, die Sie beisteuern möchten, und dann darin arbeiten.
Die Reihenfolge sieht dann in etwa so aus:

[source,console]
----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
----

[NOTE]
====
Es empfiehlt sich, die Anweisung `git rebase -i` zu verwenden, um die verschiedenen Commits zu einem einzigen zusammenzufassen oder um sie in anderer Weise neu zu arrangieren, sodass es für die Projektbetreiber leichter ist, die Änderungen zu überprüfen- – siehe <<_rewriting_history>> für weitere Informationen über interaktives Rebasing.
====

Wenn Sie mit der Arbeit an ihrem Branch fertig sind und Sie ihren Beitrag den Projektbetreibern zur Verfügung stellen wollen, gehen Sie auf die Projektseite und klicken auf den ``Fork''-Button, um Ihren eigenen Fork des Projektes anzulegen, in den Sie dann schreiben können.
Die URL des Repositorys dieses Forks müssen Sie dann als ein zweites, entferntes Repository (``remote'') einrichten, in diesem Beispiel hat es den Namen `myfork`:

[source,console]
----
$ git remote add myfork (url)
----

<<<<<<< HEAD
Dann müssen Sie Ihre Änderungen dorthin hochladen.
Am einfachsten ist es, den Themenbranch, an dem Sie gerade arbeiten, in Ihr Repository hochzuladen, anstatt ihn mit Ihrem `master`-Branch zusammenzuführen und diesen dann hochzuladen.
Der Grund dafür ist, dass Sie Ihren `master`-Branch nicht zurücksetzen müssen, falls Ihre Änderungen nicht akzeptiert werden.
Wenn die Projektbetreiber Ihre Änderungen übernehmen, ob mit `merge`, `rebase` oder `cherry-pick`, werden Sie diese schließlich sowieso zurückbekommen mittels `git pull` von deren Repository.
=======
Then you need to push your work up to it.
It's easiest to push the topic branch you're working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn't accepted or is cherry-picked, you don't have to rewind your master branch. (`cherry-pick` is covered in more detail in <<_rebase_cherry_pick>>).
If the maintainers `merge`, `rebase`, or `cherry-pick` your work, you'll eventually get it back via pulling from their repository anyhow:
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[source,console]
----
$ git push -u myfork featureA
----

(((git commands, request-pull)))
<<<<<<< HEAD
Wenn Sie Ihre Arbeit in Ihren Fork hochgeladen haben, müssen Sie den Projektbetreiber benachrichtigen.
Dies wird häufig als ``pull request'' bezeichnet und Sie können diesen entweder direkt über die Webseite erzeugen - GitHub hat seinen eigenen ``Pull Request''-Mechanismus, welchen wir in <<_github>> näher betrachten - oder Sie können die Anweisung `git request-pull` ausführen und die Ausgabe manuell per E-Mail an den Projektbetreiber schicken.
=======
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we'll go over in <<_github>> – or you can run the `git request-pull` command and email the output to the project maintainer manually.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

Die Anweisung `request-pull` nimmt den Ausgangsbranch, für den Ihre Änderungen bestimmt sind, und die URL des Git-Repositorys, von dem Ihre Änderungen heruntergeladen werden sollen, und gibt eine Zusammenfassung aller Änderungen aus, um deren Übernahme Sie bitten.
Wenn Jessica z. B. einen ``pull request'' an John schicken will, und sie zwei Commits auf dem gerade hochgeladenen Themenbranch durchgeführt hat, kann sie diese Anweisung ausführen:

[source,console]
----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
----

<<<<<<< HEAD
Die Ausgabe kann an die Projektbetreiber geschickt werden – sie sagt ihnen, auf welcher Stelle der Branch angelegt wurde, fasst die Commits zusammen und gibt an, aus welchem Fork oder Repository man die Änderungen herunterladen kann.
=======
The output can be sent to the maintainer – it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

Bei einem Projekt, wo Sie nicht selbst der Betreiber sind, ist es im Allgemeinen einfacher, einen Branch wie `master` zu haben, welcher immer den `origin/master`-Branch verfolgt, und Ihre eigenen Änderungen in Themenbranches vorzunehmen, die Sie leicht verwerfen können, wenn diese nicht akzeptiert werden.
Wenn Sie Schwerpunkte Ihrer Arbeit in Themenbranches unterteilen, können Sie diese außerdem recht leicht auf den letzten Stand des Hauptrepositorys rebasen, falls das Hauptrepository in der Zwischenzeit weiter entwickelt wurde und Ihre Commits sich nicht mehr sauber anwenden lassen.
Wollen Sie beispielsweise Änderungen zu einem weiteren Thema für das Projekt beisteuern, dann arbeiten Sie nicht weiter auf dem Themenbranch, den Sie gerade hochgeladen haben - sondern beginnen Sie von vorn vom `master`-Branch des Hauptrepositorys:

[source,console]
----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
$ git request-pull origin/master myfork
# (email maintainer)
$ git fetch origin
----

Jedes Ihrer Themen befindet sich jetzt in einer Art Silo - ähnlich zu einer Patch Queue – sodass Sie diese neu schreiben, rebasen und ändern können, ohne dass die Themen sich gegemseitig stören oder voneinander abhängen:

.Ursprünglicher Commit-Verlauf bei der Arbeit an `featureB`.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Sagen wir, der Projektbetreiber hat eine Menge von anderen Patches übernommen und versucht, Ihren ersten Branch einfließen zu lassen, aber dieser lässt sich nicht mehr sauber anwenden.
In diesem Fall können Sie Ihre Änderungen auf dem letzten Stand des `origin/master`-Branches mittels Rebase hinzufügen, die Konflikte für den Projektbetreiber beheben und Ihre Arbeit erneut einreichen:

[source,console]
----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
----

Das schreibt Ihren Commit-Verlauf neu, sodass dieser jetzt so aussieht <<psp_b>>.

[[psp_b]]
.Commit-Verlauf nach dem Rebase von `featureA`.
image::images/public-small-2.png[Commit history after `featureA` work.]

Da Sie den Branch mittels Rebase hinzugefügt haben, müssen Sie die Anweisung `git push` mit der Option `-f` verwenden, um den `featureA`-Branch auf dem Server mit einem Commit ersetzen zu können, der nicht vom gegenwärtig letzten Commit des entfernten Branches abstammt.
Eine Alternative dazu wäre, diese neuen Änderungen in einen anderen Branch auf dem Server hochzuladen (vielleicht namens `featureAv2`).

Schauen wir uns noch ein weiteres mögliches Szenario an: der Projektbetreiber hat sich Ihre Arbeit in Ihrem zweiten Branch angesehen und mag das Konzept, aber er bittet Sie, noch ein Detail an der Implementierung zu ändern.
Sie werden die Gelegenheit außerdem nutzen, um Ihre Änderungen zu verschieben, damit diese auf dem aktuellen `master`-Branch des Projektes basieren. 
Sie legen dazu ausgehend vom aktuellen `origin/master`-Branch einen neuen Branch an, führen Ihre Änderungen aus `featureB` damit zusammen, lösen dabei jegliche Konflikte, erledigen die gewünschte Änderung an der Implementierung und laden das Ganze als neuen Branch hoch:

(((git commands, merge, squash)))
[source,console]
----
$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
----

<<<<<<< HEAD
Die Option `--squash` fasst alle Änderungen des einfließenden Branches (featureB) zusammen und quetscht diese in einen Nicht-Merge-Commit an der Spitze des Branches, auf dem Sie sich gerade befinden.
Die Option `--no-commit` weist Git außerdem an, nicht automatisch einen Commit anzulegen.
Das ermöglicht Ihnen, sämtliche Änderungen aus einem anderen Branch zu übernehmen und dann weitere Änderungen vorzunehmen, bevor Sie einen neuen Commit aufzeichnen.
=======
The `--squash` option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit.
This means your future commit will have one parent only and allows you to introduce all the changes from another branch and then make more changes before recording the new commit.
Also the `--no-commit` option can be useful to delay the merge commit in case of the default merge process.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

Jetzt können Sie dem Projektbetreiber eine Nachricht schicken, dass Sie die gewünschten Änderungen vorgenommen haben und dass er Ihre Änderungen in Ihrem `featureBv2`-Branch finden kann.

.Commit-Verlauf nach den Änderungen an `featureBv2`.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
<<<<<<< HEAD
==== Öffentliches Projekt via E-Mail
=======
==== Public Project over Email
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

(((contributing, public large project)))
Viele Projekte haben festgelegte Verfahren, um Patches entgegenzunehmen - Sie werden sich mit den jeweiligen Regeln vertraut machen müssen, da diese bei jedem Projekt unterschiedlich sein werden.
Da ist etliche ältere, große Projekte gibt, welche Patches über eine Mailingliste der Entwickler entgegennehmen, werden wir auf dieses Beispiel als Nächstes eingehen.

<<<<<<< HEAD
Der Arbeitsablauf ist ähnlich dem im vorherigen Anwendungsfall - Sie erzeugen Themenbranches für jede Patchserie, an der Sie arbeiten.
Der Unterschied besteht dann darin, wie Sie die Änderungen an das Projekt übermitteln.
Anstatt das Projekt zu forken und Änderungen in Ihren Fork hochzuladen, erzeugen Sie E-Mail-Versionen von jeder Ihrer Commit-Folgen und senden diese an die Mailingliste der Entwickler.
=======
The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate email versions of each commit series and email them to the developer mailing list:
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[source,console]
----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
----

(((git commands, format-patch)))
<<<<<<< HEAD
Jetzt haben Sie zwei Commits, die Sie an die Mailingliste schicken wollen.
Sie verwenden die Anweisung `git format-patch`, um die Dateien im mbox-Format zu erzeugen, die Sie per E-Mail an die Mailingliste schicken können - diese Anweisung macht aus jedem Commit eine E-Mail-Nachricht, wobei die erste Zeile der Commit-Nachricht zum Betreff der E-Mail wird und der Rest der Commit-Nachricht sowie der Patch des Commits selbst wird zum Text der E-Mail.
Das Schöne daran ist, dass bei der Anwendung eines Patches von einer mit `format-patch` erzeugten E-Mail alle Commit-Informationen ordnungsgemäß erhalten bleiben.
=======
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can email to the list – it turns each commit into an email message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an email generated with `format-patch` preserves all the commit information properly.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[source,console]
----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
----

Die Anweisung `git format-patch` zeigt Ihnen die Namen der Patch-Dateien an, die er erzeugt hat.
Die Option `-M` weist Git an, nach umbenannten Dateien Ausschau zu halten.
Die Dateien sehen dann so aus:

[source,console]
----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
----

<<<<<<< HEAD
Sie können diese Patch-Dateien auch bearbeiten, um weitere Informationen für die Mailingliste hinzuzufügen, die nicht in der Commit-Nachricht erscheinen sollen.
Wenn Sie Text zwischen der `---` Zeile und dem Anfang des Patches (der Zeile `diff --git`) hinzufügen, dann können die Entwickler diesen lesen, bei der Anwendung des Patches wird er aber ausgeschlossen.

Um das jetzt an eine Mailingliste zu schicken, können Sie die Datei entweder in Ihrem E-Mail Programm einfügen oder sie über ein Befehlszeilen-Programm direkt verschicken.
Das Einfügen des Textes verursacht oft Formatierungsprobleme – insbesondere mit ``smarten'' E-Mail-Clients, welche Zeilenumbrüche und Leerzeichen nicht adäquat erhalten.
Zum Glück bringt Git aber ein Tool mit, was Ihnen dabei behilflich ist, ordnungsgemäß formatierte Patches über IMAP zu verschicken, was einfacher für Sie sein könnte.
Wir werden demonstrieren, wie man Patches über Gmail verschickt, welches der E-Mail-Client ist, mit dem wir uns am besten auskennen; Sie können detaillierte Anleitungen für eine Reihe von E-Mail-Programme am Ende der schon erwähnten Datei `Documentation/SubmittingPatches` im Git Quellcode nachlesen.
=======
You can also edit these patch files to add more information for the email list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), then developers can read it; but applying the patch excludes it.

To email this to a mailing list, you can either paste the file into your email program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the email agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

(((git commands, config)))(((email)))
Zunächst müssen Sie den Abschnitt IMAP in Ihrer `~/.gitconfig`-Datei einrichten.
Sie können jeden Wert separat mit einer Reihe von `git config`-Anweisungen eingeben oder die Datei öffnen und die Werte manuell eingeben, am Ende sollte Ihre config-Datei in etwa so aussehen:

[source,ini]
----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
----

<<<<<<< HEAD
Wenn Ihr IMAP-Server kein SSL verwendet, sind die letzten beiden Zeilen wahrscheinlich nicht nötig und der Host-Wert müsste `imap://` statt `imaps://` lauten.
Wenn Sie diese Einstellungen vorgenommen haben, können Sie `git send-email` verwenden, um die Patches im Entwurfsordner des angegebenen IMAP-Servers zu platzieren:
=======
If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git imap-send` to place the patch series in the Drafts folder of the specified IMAP server:
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

[source,console]
----
$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done
----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

You can also send the patches through an SMTP server.
As before, you can set each value separately with a series of `git config` commands, or you can add them manually in the sendemail section in your `~/.gitconfig` file:

[source,ini]
----
[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587
----

After this is done, you can use `git send-email` to send your patches:

[source,console]
----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
----

Git gibt dann für jeden Patch, den Sie versenden, ein paar Log-Informationen aus, die in etwa so aussehen:

[source,text]
----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
<<<<<<< HEAD
-----

Jetzt sollten Sie in der Lage sein, zum Entwurfsordner Ihres E-Mail-Clients zu gehen, als Empfänger die Adresse der Mailingliste anzugeben, an die Sie den Patch senden wollen, möglicherweise den Projektbetreiber oder einen anderen Verantwortlichen auf CC zu setzen und die E-Mail dann zu verschicken.
=======
----
>>>>>>> 811dffebd4ff1348819f8acc70f954bd4ad65057

==== Zusammenfassung

Dieser Abschnitt hat eine Reihe von gebräuchlichen Arbeitsabläufen behandelt, die für jeweils sehr verschiedene Arten von Projekten üblich sind und denen Du vermutlich begegnen wirst. Wir haben außerdem ein paar neue Tools vorgestellt, die dabei hilfreich sind, diese Workflows umzusetzen.
Als nächstes werden wir auf die andere Seite dieser Medaille eingehen: wie Sie selbst ein Git Projekt betreiben können.
Sie werden erfahren, wie Sie als „wohlwollender Diktator“ oder als Integrationsmanager arbeiten können.